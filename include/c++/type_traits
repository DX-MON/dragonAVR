// SPDX-License-Identifier: BSD-3-Clause
#ifndef TYPE_TRAITS
#define TYPE_TRAITS

#include <cstddef>

namespace std
{
	template<typename T> struct success_type { using type = T; };
	struct failure_type { };

	template<typename T, T v> struct integral_constant
	{
		using value_type = T;
		using type = integral_constant<T, v>;

		constexpr static T value = v;
		constexpr operator value_type() const noexcept { return value; }
		constexpr value_type operator ()() const noexcept { return value; }
	};

	template<typename T, T v> constexpr T integral_constant<T, v>::value;

	template<bool, typename T = void> struct enable_if { };
	template<typename T> struct enable_if<true, T> { using type = T; };
	template<bool cond, typename T = void> using enable_if_t = typename enable_if<cond, T>::type;

	template<bool cond, typename ifTrue_t, typename ifFalse_t> struct conditional
		{ using type = ifTrue_t; };
	template<typename ifTrue_t, typename ifFalse_t>
		struct conditional<false, ifTrue_t, ifFalse_t> { using type = ifFalse_t; };
	template<bool cond, typename ifTrue_t, typename ifFalse_t> using conditional_t =
		typename conditional<cond, ifTrue_t, ifFalse_t>::type;

	using true_type = integral_constant<bool, true>;
	using false_type = integral_constant<bool, false>;
	template<bool value> using _bool_constant = integral_constant<bool, value>;

	namespace impl
	{
		template<typename...> struct __or;
		template<> struct __or<> : public false_type { };
		template<typename b1_t> struct __or<b1_t> : public b1_t { };
		template<typename b1_t, typename b2_t> struct __or<b1_t, b2_t> :
			public conditional_t<b1_t::value, b1_t, b2_t> { };
		template<typename b1_t, typename b2_t, typename b3_t, typename... bn_t>
			struct __or<b1_t, b2_t, b3_t, bn_t...> : public
			conditional_t<b1_t::value, b1_t, __or<b2_t, b3_t, bn_t...>> { };

		template<typename...> struct __and;
		template<> struct __and<> : public true_type { };
		template<typename b1_t> struct __and<b1_t> : public b1_t { };
		template<typename b1_t, typename b2_t> struct __and<b1_t, b2_t> :
			public conditional_t<b1_t::value, b2_t, b1_t> { };
		template<typename b1_t, typename b2_t, typename b3_t, typename... bn_t>
			struct __and<b1_t, b2_t, b3_t, bn_t...> :
			public conditional_t<b1_t::value, __and<b2_t, b3_t, bn_t...>, b1_t> { };

		template<typename T> struct __not : public _bool_constant<!bool(T::value)> { };

		template<typename... bn_t> inline constexpr bool or_v = __or<bn_t...>::value;
		template<typename... bn_t> inline constexpr bool and_v = __and<bn_t...>::value;
		template<typename T> inline constexpr bool not_v = __not<T>::value;
	} // namespace impl

	namespace impl
	{
		template<typename T, typename U = T &&> U declval(int);
		template<typename T> T declval(long);
	}

	template<typename T> auto declval() noexcept -> decltype(impl::declval<T>(0));

	template<typename, size_t uint = 0> struct extent :
		public integral_constant<size_t, 0> { };
	template<typename T, size_t uint, size_t size> struct extent<T[size], uint> :
		public integral_constant<size_t, uint == 0 ? size : extent<T, uint - 1>::value> { };
	template<typename T, size_t uint> struct extent<T[], uint> :
		public integral_constant<size_t, uint == 0 ? 0 : extent<T, uint - 1>::value> { };
	template<typename T> constexpr inline bool extent_v = extent<T>::value;

	template<typename T, typename U> struct is_same : public false_type { };
	template<typename T> struct is_same<T, T> : public true_type { };
	template<typename T, typename U> constexpr inline bool is_same_v = is_same<T, U>::value;

	// impl for is_swappable and is_nothrow_swapable
	namespace impl
	{
		template<typename T> struct is_swappable
		{
			template<typename U, typename = decltype(swap(std::declval<U &>(), std::declval<U &>()))>
				static true_type test();
			template<typename> struct false_value test();

			using type = decltype(test<T>());
		};

		template<typename T> struct is_nothrow_swappable
		{
			template<typename U> static auto test() ->
				_bool_constant<noexcept(swap(std::declval<U &>(), std::declval<U &>()))>;
			template<typename> static false_type test();

			using type = decltype(test<T>());
		};
	} // namespace impl

	template<typename T> struct is_swappable : impl::is_swappable<T>::type { };
	template<typename T> struct is_nothrow_swappable : impl::is_nothrow_swappable<T>::type { };
	template<typename T> constexpr inline bool is_swappable_v = is_swappable<T>::value;
	template<typename T> constexpr inline bool is_nothrow_swappable_v = is_nothrow_swappable<T>::value;

	template<typename> struct is_const : public false_type { };
	template<typename T> struct is_const<const T> : public true_type { };

	template<typename> struct is_volatile : public false_type { };
	template<typename T> struct is_volatile<volatile T> : public true_type { };

	template<typename T> struct remove_const { using type = T; };
	template<typename T> struct remove_const<const T> { using type = T; };

	template<typename T> struct remove_volatile { using type = T; };
	template<typename T> struct remove_volatile<volatile T> { using type = T; };

	template<typename T> struct add_const { using type = const T; };
	template<typename T> struct add_volatile { using type = volatile T; };

	template<typename T> using remove_const_t = typename remove_const<T>::type;
	template<typename T> using remove_volatile_t = typename remove_volatile<T>::type;

	template<typename T> using add_const_t = typename add_const<T>::type;
	template<typename T> using add_volatile_t = typename add_volatile<T>::type;

	template<typename T> struct remove_cv { using type = T; };
	template<typename T> struct remove_cv<const T> { using type = T; };
	template<typename T> struct remove_cv<volatile T> { using type = T; };
	template<typename T> struct remove_cv<const volatile T> { using type = T; };

	template<typename T> struct add_cv { using type = add_const_t<add_volatile_t<T>>; };

	template<typename T> struct remove_reference { using type = T; };
	template<typename T> struct remove_reference<T &> { using type = T; };
	template<typename T> struct remove_reference<T &&> { using type = T; };

	template<typename T> struct remove_extent { using type = T; };
	template<typename T, size_t size> struct remove_extent<T [size]>
		{ using type = T; };
	template<typename T> struct remove_extent<T []> { using type = T; };

	template<typename T> struct remove_all_extents { using type = T; };
	template<typename T, size_t size> struct remove_all_extents<T [size]>
		{ using type = typename remove_all_extents<T>::type; };
	template<typename T> struct remove_all_extents<T []>
		{ using type = typename remove_all_extents<T>::type; };

	template<typename T> inline constexpr bool is_const_v = is_const<T>::value;
	template<typename T> inline constexpr bool is_volatile_v = is_volatile<T>::value;

	template<typename T> using remove_cv_t = typename remove_cv<T>::type;
	template<typename T> using add_cv_t = typename add_cv<T>::type;
	template<typename T> using remove_reference_t = typename remove_reference<T>::type;
	template<typename T> using remove_cvref_t = remove_cv_t<remove_reference_t<T>>;
	template<typename T> using remove_extent_t = typename remove_extent<T>::type;
	template<typename T> using remove_all_extents_t = typename remove_all_extents<T>::type;

	// impl for is_integral
	namespace impl
	{
		template<typename> struct is_integral : public false_type { };
		template<> struct is_integral<bool> : public true_type { };
		template<> struct is_integral<char> : public true_type { };
		template<> struct is_integral<signed char> : public true_type { };
		template<> struct is_integral<unsigned char> : public true_type { };
		template<> struct is_integral<char16_t> : public true_type { };
		template<> struct is_integral<char32_t> : public true_type { };
		template<> struct is_integral<short> : public true_type { };
		template<> struct is_integral<unsigned short> : public true_type { };
		template<> struct is_integral<int> : public true_type { };
		template<> struct is_integral<unsigned int> : public true_type { };
		template<> struct is_integral<long> : public true_type { };
		template<> struct is_integral<unsigned long> : public true_type { };
		template<> struct is_integral<long long> : public true_type { };
		template<> struct is_integral<unsigned long long> : public true_type { };
	} // namespace impl

	template<typename T> struct is_integral : impl::is_integral<remove_cv_t<T>>::type { };
	template<typename T> inline constexpr bool is_integral_v = is_integral<T>::value;

	template<typename T> struct is_enum : public integral_constant<bool, __is_enum(T)> { };
	template<typename T> struct is_union : public integral_constant<bool, __is_union(T)> { };
	template<typename T> struct is_class : public integral_constant<bool, __is_class(T)> { };

	template<typename T> inline constexpr bool is_enum_v = is_enum<T>::value;
	template<typename T> inline constexpr bool is_union_v = is_union<T>::value;
	template<typename T> inline constexpr bool is_class_v = is_class<T>::value;

	// impl for is_null_pointer
	namespace impl
	{
		template<typename> struct is_null_pointer : public false_type { };
		template<> struct is_null_pointer<std::nullptr_t> : public false_type { };
	} // namespace impl

	template<typename T> struct is_null_pointer : public impl::is_null_pointer<remove_cv_t<T>> { };
	template<typename T> inline constexpr bool is_null_pointer_v = is_null_pointer<T>::value;

	// impl for is_floating_point
	namespace impl
	{
		template<typename> struct is_floating_point : public false_type { };
		template<> struct is_floating_point<float> : public true_type { };
		template<> struct is_floating_point<double> : public true_type { };
		template<> struct is_floating_point<long double> : public true_type { };
	} // namespace impl

	template<typename T> struct is_floating_point : public impl::is_floating_point<remove_cv_t<T>> { };
	template<typename T> inline constexpr bool is_floating_point_v = is_floating_point<T>::value;

	template<typename...> struct tuple;

	// impl for is_tuple_like
	namespace impl
	{
		template<typename> struct is_tuple_like : false_type { };
		template<typename... Ts> struct is_tuple_like<tuple<Ts...>> : true_type { };
	}

	template<typename T> struct is_tuple_like : public impl::is_tuple_like<remove_cvref_t<T>>::type { };
	template<typename T> constexpr inline bool is_tuple_like_v = is_tuple_like<T>::value;

	// impl for is_void
	namespace impl
	{
		template<typename> struct is_void : public false_type { };
		template<> struct is_void<void> : public true_type { };
	}

	template<typename T> struct is_void : public impl::is_void<remove_cv_t<T>> { };
	template<typename T> inline constexpr bool is_void_v = is_void<T>::value;

	template<typename> struct is_lvalue_reference : public false_type { };
	template<typename T> struct is_lvalue_reference<T &> : public true_type { };
	template<typename T> inline constexpr bool is_lvalue_reference_v =
		is_lvalue_reference<T>::value;

	template<typename> struct is_rvalue_reference : public false_type { };
	template<typename T> struct is_rvalue_reference<T &&> : public true_type { };
	template<typename T> inline constexpr bool is_rvalue_reference_v =
		is_rvalue_reference<T>::value;


	template<typename T> struct is_reference : public _bool_constant<
		is_lvalue_reference_v<T> || is_rvalue_reference_v<T>> { };
	template<typename T> inline constexpr bool is_reference_v = is_reference<T>::value;

	template<typename T> struct is_arithmetic : public _bool_constant<
		is_integral_v<T> || is_floating_point_v<T>> { };
	template<typename T> inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;

	template<typename T> struct is_fundamental : public _bool_constant<
		is_arithmetic_v<T> || is_void_v<T> || is_null_pointer_v<T>> { };
	template<typename T> inline constexpr bool is_fundamental_v = is_fundamental<T>::value;

	template<typename> struct is_function : public false_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) & noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) && noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) & noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) && noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) const noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) const & noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) const && noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) const noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) const & noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) const && noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) volatile noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) volatile & noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) volatile && noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) volatile noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) volatile & noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) volatile && noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) const volatile noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) const volatile & noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t...) const volatile && noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) const volatile noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) const volatile & noexcept(ne)> : public true_type { };
	template<typename res_t, typename... args_t, bool ne>
		struct is_function<res_t(args_t......) const volatile && noexcept(ne)> : public true_type { };
	template<typename T> inline constexpr bool is_function_v = is_function<T>::value;

	template<typename T> struct is_object :
		public _bool_constant<!(is_function_v<T> || is_reference_v<T> || is_void_v<T>)> { };
	template<typename T> inline constexpr bool is_object_v = is_object<T>::value;

	template<typename> struct is_array : public false_type { };
	template<typename T, size_t size> struct is_array<T[size]> : public true_type { };
	template<typename T> struct is_array<T[]> : public true_type { };
	template<typename T> inline constexpr bool is_array_v = is_array<T>::value;

	// impl of is_pointer, is_member_object_pointer and is_member_function_pointer
	namespace impl
	{
		template<typename> struct is_pointer : public false_type { };
		template<typename T> struct is_pointer<T *> : public true_type { };

		template<typename> struct is_member_object_pointer : public false_type { };
		template<typename T, typename C> struct is_member_object_pointer<T C::*> :
			public __not<is_function<T>> { };

		template<typename> struct is_member_function_pointer : public false_type { };
		template<typename T, typename C> struct is_member_function_pointer<T C::*> :
			public is_function<T> { };
	} // namespace impl

	template<typename T> struct is_pointer : public impl::is_pointer<remove_cv_t<T>> { };
	template<typename T> struct is_member_object_pointer : public impl::is_member_object_pointer<remove_cv_t<T>> { };
	template<typename T> struct is_member_function_pointer : public impl::is_member_function_pointer<remove_cv_t<T>> { };
	template<typename T> inline constexpr bool is_pointer_v = is_pointer<T>::value;
	template<typename T> inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<T>::value;
	template<typename T> inline constexpr bool is_member_function_pointer_v = is_member_function_pointer<T>::value;

	// impl for is_member_pointer
	namespace impl
	{
		template<typename T> struct is_member_pointer : public false_type { };
		template<typename T, typename C> struct is_member_pointer<T C::*> : public true_type { };
	} // namespace impl

	template<typename T> struct is_member_pointer : public impl::is_member_pointer<remove_cv_t<T>> { };
	template<typename T> inline constexpr bool is_member_pointer_v = is_member_pointer<T>::value;

	template<typename T> struct is_scalar : public _bool_constant<
		is_arithmetic_v<T> || is_enum_v<T> || is_pointer_v<T> || is_member_pointer_v<T> || is_null_pointer_v<T>> { };
	template<typename T> inline constexpr bool is_scalar_v = is_scalar<T>::value;

	template<typename...> using void_t = void;

	// impl of is_referenceable and is_convertible
	namespace impl
	{
		template<typename T> struct is_referenceable : public _bool_constant<
			is_object_v<T> || is_reference_v<T>> { };
		template<typename res_t, typename... args_t, bool ne>
			struct is_referenceable<res_t(args_t...) noexcept(ne)> :public true_type { };
		template<typename res_t, typename... args_t, bool ne>
			struct is_referenceable<res_t(args_t......) noexcept(ne)> : public true_type { };

		template<typename from_t, typename to_t, bool = is_void_v<from_t> || is_function_v<to_t> || is_array_v<to_t>>
			struct is_convertible { using type = typename std::is_void<to_t>::type; };

		template<typename from_t, typename to_t>
			struct is_convertible<from_t, to_t, false>
		{
		private:
			template<typename to1_t> static void testAux(to1_t) noexcept;

			template<typename from1_t, typename to1_t, typename = decltype(testAux<to1_t>(std::declval<from1_t>()))>
				static true_type test(int);
			template<typename, typename> static false_type test(...);

		public:
			using type = decltype(test<from_t, to_t>(0));
		};
	} // namespace impl

	template<typename from_t, typename to_t> struct is_convertible :
		public impl::is_convertible<from_t, to_t>::type { };
	template<typename from_t, typename to_t> inline constexpr bool is_convertible_v =
		is_convertible<from_t, to_t>::value;

	// impl for add_lvalue_reference and add_rvalue_reference
	namespace impl
	{
		template<typename T, bool = is_referenceable<T>::value> struct add_lvalue_reference
			{ using type = T; };
		template<typename T> struct add_lvalue_reference<T, true>
			{ using type = T &; };

		template<typename T, bool = is_referenceable<T>::value> struct add_rvalue_reference
			{ using type = T; };
		template<typename T> struct add_rvalue_reference<T, true>
			{ using type = T &&; };
	} // namespace impl

	template<typename T> struct add_lvalue_reference : public impl::add_lvalue_reference<T> { };
	template<typename T> struct add_rvalue_reference : public impl::add_rvalue_reference<T> { };

	template<typename T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
	template<typename T> using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

	// impl for add_pointer and remove_pointer
	namespace impl
	{
		template<typename T, bool = is_referenceable<T>::value || is_void_v<T>>
			struct add_pointer { using type = T; };
		template<typename T> struct add_pointer<T, true> { using type = remove_reference_t<T> *; };

		template<typename T, typename> struct remove_pointer { using type = T; };
		template<typename T, typename U> struct remove_pointer<T, U *> { using type = U; };
	} // namespace impl

	template<typename T> struct add_pointer : public impl::add_pointer<T> { };
	template<typename T> struct remove_pointer : public impl::remove_pointer<T, remove_cv_t<T>> { };
	template<typename T> using add_pointer_t = typename add_pointer<T>::type;
	template<typename T> using remove_pointer_t = typename remove_pointer<T>::type;

	// impl of decay
	namespace impl
	{
		template<typename T, bool isArray = is_array_v<T>, bool isFunction = is_function_v<T>> struct decay;
		template<typename T> struct decay<T, false, false> { using type = remove_cv_t<T>; };
		template<typename T> struct decay<T, true, false> { using type = remove_extent_t<T> *; };
		template<typename T> struct decay<T, false, true> { using type = add_pointer_t<T>; };
	} // namespace impl

	template<typename T> struct decay
	{
	private:
		using remove_t = remove_reference_t<T>;

	public:
		using type = typename impl::decay<remove_t>::type;
	};

	template<typename T> using decay_t = typename decay<T>::type;

	template<typename T> struct reference_wrapper;

	// impl for decay_and_strip
	namespace impl
	{
		template<typename T> struct strip_reference_wrapper { using type = T; };
		template<typename T> struct strip_reference_wrapper<reference_wrapper<T>> { using type = T &; };

		template<typename T> struct decay_and_strip : strip_reference_wrapper<decay_t<T>> { };
		template<typename T> using decay_and_strip_t = typename decay_and_strip<T>::type;
	} // namespace impl

	// impl for is_signed
	namespace impl
	{
		template<typename T> constexpr inline bool _is_signed() noexcept { return T(-1) < T(0); }
		// Should be is_arithmetic, but..
		template<typename T, bool = std::is_integral<T>::value> struct is_signed : false_type { };
		template<typename T> struct is_signed<T, true> : public _bool_constant<_is_signed<T>()> { };
	} // namespace impl

	template<typename T> struct is_signed : impl::is_signed<T>::type { };
	template<typename T> inline constexpr bool is_signed_v = is_signed<T>::value;

	template<typename T> struct is_unsigned : public _bool_constant<is_arithmetic_v<T> && !is_signed_v<T>> { };
	template<typename T> inline constexpr bool is_unsigned_v = is_unsigned<T>::value;

	// impl for match_cv_qualifiers
	namespace impl
	{
		template<typename, bool isConst, bool isVolat> struct cv_selector;
		template<typename unqal_t> struct cv_selector<unqal_t, false, false> { using type = unqal_t; };
		template<typename unqal_t> struct cv_selector<unqal_t, true, false> { using type = const unqal_t; };
		template<typename unqal_t> struct cv_selector<unqal_t, false, true> { using type = volatile unqal_t; };
		template<typename unqal_t> struct cv_selector<unqal_t, true, true> { using type = const volatile unqal_t; };

		template<typename qual_t, typename unqual_t, bool isConst = std::is_const_v<qual_t>,
			bool isVolat = std::is_volatile_v<qual_t>> struct match_cv_qualifiers
		{
			using match_t = cv_selector<unqual_t, isConst, isVolat>;
			using type = typename match_t::type;
		};
	} // namespace impl

	// impl for make_unsigned
	namespace impl
	{
		template<typename T> struct make_unsigned { using type = T; };
		template<> struct make_unsigned<char> { using type = unsigned char; };
		template<> struct make_unsigned<signed char> { using type = unsigned char; };
		template<> struct make_unsigned<signed short> { using type = unsigned short; };
		template<> struct make_unsigned<signed int> { using type = unsigned int; };
		template<> struct make_unsigned<signed long> { using type = unsigned long; };
		template<> struct make_unsigned<signed long long> { using type = unsigned long long; };

		template<typename T, bool isInt = is_integral_v<T>, bool isEnum = is_enum_v<T>> struct make_unsigned_selector;

		template<typename T> struct make_unsigned_selector<T, true, false>
		{
			using unsigned_type = typename make_unsigned<std::remove_cv_t<T>>::type;
			using type = typename match_cv_qualifiers<T, unsigned_type>::type;
		};

		struct make_smallest_unsigned
		{
		protected:
			template<typename...> struct list_t { };

			template<typename T, typename... Us> struct list_t<T, Us...> : list_t<Us...>
				{ constexpr static std::size_t size = sizeof(T); };

			template<size_t size, typename T, bool = (size <= T::size)> struct select_t;
			template<size_t size, typename uint_t, typename... uints_t>
				struct select_t<size, list_t<uint_t, uints_t...>, true>
					{ using type = uint_t; };
			template<size_t size, typename uint_t, typename... uints_t>
				struct select_t<size, list_t<uint_t, uints_t...>, false> :
					select_t<size, list_t<uints_t...>> { };
		};

		template<typename T> struct make_unsigned_selector<T, false, true> : make_smallest_unsigned
		{
			using uints_t = list_t<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
			using unsigned_type = typename select_t<sizeof(T), uints_t>::type;
			using type = typename match_cv_qualifiers<T, unsigned_type>::type;
		};

		template<> struct make_unsigned<wchar_t>
			{ using type = typename make_unsigned_selector<wchar_t, false, true>::type; };

		template<> struct make_unsigned<char16_t>
			{ using type = typename make_unsigned_selector<char16_t, false, true>::type; };

		template<> struct make_unsigned<char32_t>
			{ using type = typename make_unsigned_selector<char32_t, false, true>::type; };
	} // namespace impl

	template<typename T> struct make_unsigned
		{ using type = typename impl::make_unsigned_selector<T>::type; };
	template<> struct make_unsigned<bool>;

	template<typename T> using make_unsigned_t = typename make_unsigned<T>::type;

	// impl for make_signed
	namespace impl
	{
		template<typename T> struct make_signed { using type = T; };
		template<> struct make_signed<char> { using type = signed char; };
		template<> struct make_signed<unsigned char> { using type = signed char; };
		template<> struct make_signed<unsigned short> { using type = signed short; };
		template<> struct make_signed<unsigned int> { using type = signed int; };
		template<> struct make_signed<unsigned long> { using type = signed long; };
		template<> struct make_signed<unsigned long long> { using type = signed long long; };

		template<typename T, bool isInt = is_integral_v<T>, bool isEnum = is_enum_v<T>> struct make_signed_selector;
		template<typename T> struct make_signed_selector<T, true, false>
		{
			using signed_type = typename make_signed<std::remove_cv_t<T>>::type;
			using type = typename match_cv_qualifiers<T, signed_type>::type;
		};

		template<typename T> struct make_signed_selector<T, false, true>
		{
			using unsigned_type = typename make_unsigned_selector<T, false, true>::type;
			using type = typename make_signed_selector<unsigned_type>::type;
		};

		template<> struct make_signed<wchar_t>
			{ using type = typename make_signed_selector<wchar_t, false, true>::type; };

		template<> struct make_signed<char16_t>
			{ using type = typename make_signed_selector<char16_t, false, true>::type; };

		template<> struct make_signed<char32_t>
			{ using type = typename make_signed_selector<char32_t, false, true>::type; };
	} // namespace impl

	template<typename T> struct make_signed
		{ using type = typename impl::make_signed_selector<T>::type; };
	template<> struct make_signed<bool>;

	template<typename T> using make_signed_t = typename make_signed<T>::type;

	namespace impl
	{
		template<typename T> struct is_array_known_bounds :
			public _bool_constant<(extent<T>::value > 0)> { };
		template<typename T> inline constexpr bool is_array_known_bounds_v =
			is_array_known_bounds<T>::value;

		template<typename T> struct is_array_unknown_bounds :
			public _bool_constant<is_array_v<T> && !extent_v<T>> { };
		template<typename T> inline constexpr bool is_array_unknown_bounds_v =
			is_array_unknown_bounds<T>::value;
	} // namespace impl

	template<typename T, typename... args_t> struct is_constructible :
		public _bool_constant<__is_constructible(T, args_t...)>
	{
		//static_assert(impl::is_complete_or_unbounded(impl::type_identity<T>{}),
		//	"template argument must be a complete class or an unbounded array");
	};
	template<typename T, typename... args_t> inline constexpr bool is_constructible_v =
		is_constructible<T, args_t...>::value;

	// impl for is_nothrow_default_constructible, is_nothrow_constructible and
	// is_nothrow_move_constructible
	namespace impl
	{
		template<typename T> struct is_implicitly_default_constructible_safe
		{
		private:
			template<typename U> static void helper(const U &);
			template<typename U> static true_type test(const U &, decltype(helper<const U &>({})) * = nullptr);
			template<typename U> static false_type test(...);

		public:
			using type = decltype(test(declval<T>()));
		};

		template<typename T> struct is_implicitly_default_constructible :
			public _bool_constant<is_constructible_v<T> && is_implicitly_default_constructible_safe<T>::type::value> { };

		template<typename T> struct is_default_constructible
		{
			template<typename U, typename = decltype(U())> static true_type test(int);
			template<typename> static false_type test(...);

			using type = decltype(test<T>(0));
		};

		template<typename T> struct is_default_constructible_atom :
			public _bool_constant<!is_void_v<T> && is_default_constructible<T>::type::value> { };

		template<typename T, bool = is_array_v<T>> struct is_default_constructible_safe;
		template<typename T> struct is_default_constructible_safe<T, true> :
			public _bool_constant<is_array_known_bounds_v<T> &&
			is_default_constructible_atom<remove_all_extents_t<T>>::value> { };
		template<typename T> struct is_default_constructible_safe<T, false> :
			public is_default_constructible_atom<T> { };

		template<typename T, bool = is_referenceable<T>::value> struct is_copy_constructible;
		template<typename T> struct is_copy_constructible<T, false> : public false_type { };
		template<typename T> struct is_copy_constructible<T, true> :
			public _bool_constant<__is_constructible(T, const T &)> { };

		template<typename T, bool = is_referenceable<T>::value> struct is_move_constructible;
		template<typename T> struct is_move_constructible<T, false> : public false_type { };
		template<typename T> struct is_move_constructible<T, true> :
			public _bool_constant<__is_constructible(T, T &&)> { };

		template<typename T> struct is_nothrow_default_constructible_atom :
			public _bool_constant<noexcept(T{})> { };

		template<typename T, bool = is_array_v<T>> struct is_nothrow_default_constructible;
		template<typename T> struct is_nothrow_default_constructible<T, true> :
			public _bool_constant<is_array_known_bounds_v<T> &&
			is_nothrow_default_constructible_atom<remove_all_extents_t<T>>::value> { };
		template<typename T> struct is_nothrow_default_constructible<T, false> :
			public is_nothrow_default_constructible_atom<T> { };

		template<bool, typename, typename...> struct is_nothrow_constructible : public false_type { };
		template<typename T, typename... args_t> struct is_nothrow_constructible<true, T, args_t...> :
			public _bool_constant<noexcept(T(std::declval<args_t>()...))> { };
		template<typename T, typename arg_t> struct is_nothrow_constructible<true, T, arg_t> :
			public _bool_constant<noexcept(static_cast<T>(std::declval<arg_t>()))> { };
		template<typename T> struct is_nothrow_constructible<true, T> : public _bool_constant<noexcept(T{})> { };
		template<typename T, size_t num> struct is_nothrow_constructible<true, T [num]> :
			public _bool_constant<noexcept(remove_all_extents_t<T>::type())> { };

		template<typename T, typename... args_t> using is_nothrow_constructible_t =
			typename is_nothrow_constructible<__is_constructible(T, args_t...), T, args_t...>::type;

		template<typename T, bool = is_referenceable<T>::value>
			struct is_nothrow_move_constructible;

		template<typename T> struct is_nothrow_move_constructible<T, false> : public false_type { };
		template<typename T> struct is_nothrow_move_constructible<T, true> :
			public is_nothrow_constructible_t<T, T &&> { };

		template<typename T, bool = is_referenceable<T>::value> struct is_copy_assignable;
		template<typename T> struct is_copy_assignable<T, false> : public false_type { };
		template<typename T> struct is_copy_assignable<T, true> :
			public _bool_constant<__is_assignable(T &, const T &)> { };

		template<typename T, bool = is_referenceable<T>::value> struct is_move_assignable;
		template<typename T> struct is_move_assignable<T, false> : public false_type { };
		template<typename T> struct is_move_assignable<T, true> :
			public _bool_constant<__is_assignable(T &, T &&)> { };

		template<typename T, typename U> struct is_nothrow_assignable :
			public _bool_constant<noexcept(std::declval<T>() = std::declval<U>())> { };
	} // namespace impl

	template<typename T> struct is_default_constructible :
		public impl::is_default_constructible_safe<T>::type { };

	template<typename T> inline constexpr bool is_default_constructible_v =
		is_default_constructible<T>::value;

	template<typename T> struct is_copy_constructible : public impl::is_copy_constructible<T>
	{
		//static_assert(impl::is_complete_or_unbounded(impl::type_identity<T>{}),
		//	"template argument must be a complete class or an unbounded array");
	};

	template<typename T> struct is_move_constructible : public impl::is_move_constructible<T>
	{
		//static_assert(impl::is_complete_or_unbounded(impl::type_identity<T>{}),
		//	"template argument must be a complete class or an unbounded array");
	};

	template<typename T> struct is_nothrow_default_constructible :
		public _bool_constant<is_default_constructible_v<T> &&
		impl::is_nothrow_default_constructible<T>::value> { };
	template<typename T, typename... args_t> struct is_nothrow_constructible :
		public impl::is_nothrow_constructible_t<T, args_t...> { };
	template<typename T> struct is_nothrow_move_constructible :
		public impl::is_nothrow_move_constructible<T> { };

	template<typename T, typename U> struct is_assignable :
		public _bool_constant<__is_assignable(T, U)>
	{
		//static_assert(impl::is_complete_or_unbounded(impl::type_identity<T>{}),
		//	"template argument must be a complete class or an unbounded array");
	};

	template<typename T> struct is_copy_assignable : public impl::is_copy_assignable<T>::type
	{
		//static_assert(impl::is_complete_or_unbounded(impl::type_identity<T>{}),
		//	"template argument must be a complete class or an unbounded array");
	};

	template<typename T> struct is_move_assignable : public impl::is_move_assignable<T>::type
	{
		//static_assert(impl::is_complete_or_unbounded(impl::type_identity<T>{}),
		//	"template argument must be a complete class or an unbounded array");
	};

	template<typename T, typename U> struct is_nothrow_assignable :
		public _bool_constant<__is_assignable(T, U) && impl::is_nothrow_assignable<T, U>::value>
	{
		//static_assert(impl::is_complete_or_unbounded(impl::type_identity<T>{}),
		//	"template argument must be a complete class or an unbounded array");
	};

	namespace impl
	{
		template<typename T, bool = is_referenceable<T>::value> struct is_nothrow_copy_assignable;
		template<typename T> struct is_nothrow_copy_assignable<T, false> : public false_type { };
		template<typename T> struct is_nothrow_copy_assignable<T, true> :
			public std::is_nothrow_assignable<T &, const T &> { };

		template<typename T, bool = is_referenceable<T>::value> struct is_nothrow_move_assignable;
		template<typename T> struct is_nothrow_move_assignable<T, false> : public false_type { };
		template<typename T> struct is_nothrow_move_assignable<T, true> :
			public std::is_nothrow_assignable<T &, T &&> { };
	} // namespace impl

	template<typename T> struct is_nothrow_copy_assignable :
		public impl::is_nothrow_copy_assignable<T>
	{
		//static_assert(impl::is_complete_or_unbounded(impl::type_identity<T>{}),
		//	"template argument must be a complete class or an unbounded array");
	};

	template<typename T> struct is_nothrow_move_assignable :
		public impl::is_nothrow_move_assignable<T>
	{
		//static_assert(impl::is_complete_or_unbounded(impl::type_identity<T>{}),
		//	"template argument must be a complete class or an unbounded array");
	};

	template<typename T> struct is_empty : public integral_constant<bool, __is_empty(T)> { };
	template<typename T> struct is_final : public integral_constant<bool, __is_final(T)> { };

	template<typename T> inline constexpr bool is_copy_constructible_v =
		is_copy_constructible<T>::value;
	template<typename T> inline constexpr bool is_move_constructible_v =
		is_move_constructible<T>::value;
	template<typename T> inline constexpr bool is_nothrow_default_constructible_v =
		is_nothrow_default_constructible<T>::value;
	template<typename T> inline constexpr bool is_nothrow_constructible_v =
		is_nothrow_constructible<T>::value;
	template<typename T> inline constexpr bool is_nothrow_move_constructible_v =
		is_nothrow_move_constructible<T>::value;

	template<typename T, typename U> inline constexpr bool is_assignable_v = is_assignable<T, U>::value;
	template<typename T> inline constexpr bool is_copy_assignable_v = is_copy_assignable<T>::value;
	template<typename T> inline constexpr bool is_move_assignable_v = is_move_assignable<T>::value;
	template<typename T, typename U> inline constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<T, U>::value;
	template<typename T> inline constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<T>::value;
	template<typename T> inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<T>::value;

	template<typename T> inline constexpr bool is_empty_v = is_empty<T>::value;
	template<typename T> inline constexpr bool is_final_v = is_final<T>::value;

	constexpr bool is_constant_evaluated() noexcept
	{
#if defined(__GNUC__)
		return __builtin_is_constant_evaluated();
#else
		return false;
#endif
	}

	namespace impl
	{
		struct noneSuchBase_t {};
		struct noneSuch_t : private noneSuchBase_t
		{
			noneSuch_t(const noneSuch_t &) = delete;
			~noneSuch_t() = delete;
			void operator =(const noneSuch_t &) = delete;
		};
	} // namespace impl

	// impl of result_of/invoke_result
	namespace impl
	{
		struct invoke_memfun_ref { };
		struct invoke_memfun_deref { };
		struct invoke_memobj_ref { };
		struct invoke_memobj_deref { };
		struct invoke_other { };

		template<typename T, typename tag_t> struct result_of_success : success_type<T>
			{ using invoke_type = tag_t; };

		template<typename tag_t, typename memPtr_t, typename arg_t> struct result_of_memobj_
		{
			template<typename F, typename T> static result_of_success<
				decltype((*std::declval<T>()).*std::declval<F>()), tag_t> test(int);
			template<typename...> static failure_type test(...);

			using type = decltype(test<memPtr_t, arg_t>(0));
		};

		template<typename tag_t, typename memPtr_t, typename arg_t, typename... argTypes_t> struct result_of_memfun_
		{
			template<typename Fn, typename T, typename... args_t> static result_of_success<
				decltype(((*std::declval<T>()).*std::declval<Fn>())(std::declval<args_t>()...)),
				tag_t> test(int);
			template<typename...> static failure_type test(...);

			using type = decltype(test<memPtr_t, arg_t, argTypes_t...>(0));
		};

		template<typename memPtr_t, typename arg_t> struct result_of_memobj;
		template<typename result_t, typename class_t, typename arg_t>
			struct result_of_memobj<result_t class_t::*, arg_t>
		{
			using argVal_t = remove_cvref_t<arg_t>;
			using memPtr_t = result_t class_t::*;
			using type = typename conditional_t<std::is_same_v<argVal_t, class_t> ||
					std::is_base_of_v<class_t, argVal_t>,
				result_of_memobj_<invoke_memobj_ref memPtr_t, arg_t>,
				result_of_memobj_<invoke_memobj_deref, memPtr_t, arg_t>
			>::type;
		};

		template<typename memPtr_t, typename arg_t, typename... args_t> struct result_of_memfun;
		template<typename result_t, typename class_t, typename arg_t, typename... args_t>
			struct result_of_memfun<result_t class_t::*, arg_t, args_t...>
		{
			using argVal_t = remove_reference_t<arg_t>;
			using memPtr_t = result_t class_t::*;
			using type = typename conditional_t<std::is_base_of_v<class_t, argVal_t>,
				result_of_memfun_<invoke_memfun_ref, memPtr_t, arg_t, args_t...>,
				result_of_memfun_<invoke_memfun_deref, memPtr_t, arg_t, args_t...>
			>::type;
		};

		template<typename T, typename U = remove_cvref_t<T>> struct invoc_unwrap { using type = T; };
		template<typename T, typename U> struct invoc_unwrap<T, reference_wrapper<U>> { using type = U &; };

		template<bool, bool, typename functor_t, typename... argTypes_t> struct result_of
			{ using type = std::failure_type; };
		template<typename memPtr_t, typename arg_t>
			struct result_of<true, false, memPtr_t, arg_t> :
				public result_of_memobj<std::decay_t<memPtr_t>, invoc_unwrap<arg_t>::type> { };
		template<typename memPtr_t, typename arg_t, typename... args_t>
			struct result_of<false, true, memPtr_t, arg_t, args_t...> :
				public result_of_memfun<std::decay_t<memPtr_t>, invoc_unwrap<arg_t>::type, args_t...> { };

		template<typename functor_t, typename... argTypes_t>
			struct result_of<false, false, functor_t, argTypes_t...>
		{
			template<typename fn_t, typename... args_t> static result_of_success<
				decltype(std::declval<fn_t>()(std::declval<args_t>()...)), invoke_other> test(int);
			template<typename...> static std::failure_type test(...);

			using type = decltype(test<functor_t, argTypes_t...>(0));
		};
	} // namespace impl

	template<typename functor_t, typename... argTypes_t> struct invoke_result : public
		impl::result_of<is_member_object_pointer_v<remove_reference_t<functor_t>>,
			is_member_function_pointer_v<remove_reference_t<functor_t>>, functor_t, argTypes_t...>::type
	{
		//static_assert(impl::is_complete_or_unbounded(impl::type_identity<functor_t>{}),
		//	"functor_t must be a complete class or an unbounded array");
		//static_assert((impl::is_complete_or_unbounded(impl::type_identity<argTypes_t>{}) && ...),
		//	"each argument type must be a complete class or an unbounded array");
	};

	template<typename signature_t> struct result_of;
	template<typename functor_t, typename... argsTypes_t> struct result_of<functor_t(argsTypes_t...)> :
		public invoke_result<functor, argsTypes_t...> { };

	template<typename T> using result_of_t = typename result_of<T>::type;
	template<typename fn_t, typename... args_t> using invoke_result_t = typename invoke_result<fn_t, args_t...>::type;

	// impl of is_invocable
	namespace impl
	{
		template<typename result_t, typename ret_t, bool = is_void_v<ret_t>, typename = void>
			struct is_invocable : false_type { };
		template<typename result_t, typename ret_t> struct is_invocable<result_t, ret_t, true,
			std::void_t<typename result_t::type>> : true_type { };

		template<typename result_t, typename ret_t> struct is_invocable<result_t, ret_t, false,
			std::void_t<typename result_t::type>>
		{
		private:
			static typename result_t::type get();
			template<typename T> static void conv(T);
			template<typename T, typename = decltype(conv<T>(get()))> static true_type test(int);
			template<typename T> static false_type test(...);

		public:
			using type = decltype(test<ret_t>(1));
		};
	} // namespace impl

	template<typename fn_t, typename... args_t> struct is_invocable :
		impl::is_invocable<invoke_result<fn_t, args_t...>, void>::type
	{
		//static_assert(impl::is_complete_or_unbounded(impl::type_identity<fn_t>{}),
		//	"fn_t must be a complete class or an unbounded array");
		//static_assert((impl::is_complete_or_unbounded(impl::type_identity<args_t>{}) && ...),
		//	"each argument type must be a complete class or an unbounded array");
	};

	template<typename fn_t, typename... args_t> inline constexpr bool is_invocable_v =
		is_invocable<fn_t, args_t...>::value;
} // namespace std

#endif /*TYPE_TRAITS*/
